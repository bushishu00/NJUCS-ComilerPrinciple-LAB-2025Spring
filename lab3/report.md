## Lab3 实验报告

### 学生信息

姓名：李子沐；学号：221180029；邮箱：221180029@smail.nju.edu.cn

### 实验环境和编译方法

实验环境与OJ要求相同，使用makefile编译即可。

### 实现功能和细节

完成实验要求的必做和选做部分。细节如下：
问题一：新的数据结构，Operand和InterCode，基于InterCode实现了一个循环双向链表InterCodeList，通过遍历列表进行中间代码输出。这一部分比较常规因此不做代码展示。

**问题二：修复lab2留下的坑。**
本部分是我认为我在lab3中比较精彩的点，尽量减少前面的代码修改并利用合理的假设简化了设计。
1. 空表问题：由于lab2使用scope在每次进入/退出新的作用域时压栈/弹栈。因此整个语义分析结束后符号表已经空空如也，没办法查表了。
解决方法：只压栈，不弹栈。例如下面的Program的全局作用域不弹栈，因此全局的符号被保留；其余同理
```C
    /* Scope: Global */
    scope_begin();
    ExtDefList(get_child(root, 0));
    check_undef_func();
    //scope_end();
```

2. 结构体的偏移量：原本没有将结构体的域名存入符号表，因此无法根据更新后的符号表获得偏移量（更严肃的问题是对于Exp Dot ID无法访问ID），然而如果在语义分析中修改的话，一方面要在原本的代码中零散地混入插入结构体域名的代码，另一方面我认为将语义分析和中间代码生成混合不是一个好的选择，应尽可能保证二者的独立。
解决方法：我在lab2中使用了struct table存储了所有的结构体，我在translate_Pragram中调用了`void insert_struct(StructureTable *structTable)`统一将所有的结构体的域名插入到符号表中。

3. 提供了支持局部作用域的思路：通过问题1的解决方案，语义分析可以向中间代码传递完整（或仅全局的...根据需求设置）的符号表，但是问题是这些符号表（十字链表）无法通过简单的直接在哈希表的轴上查找最近的一个声明，因为此刻最近的大概率是一个局部变量，很可能不是我们希望找到的符号。为此我希望在翻译的过程中能够逐步的恢复当时的符号表情景。
这显然是可行的，因为符号表的作用域轴（ScopeStack）完整保留了所有的作用域信息。那么我要做的就是根据整个完整的信息恢复到某一刻的不完整的信息。因此我定义了一个SnapShot结构，代表某时刻下的符号表和作用域，外部（来自语义分析）的完整作用域和符号表始终不变，根据进入/离开作用域，来更新SnapShot。
```C
struct snapshot {
    HashTable *curTable;
    ScopeStack *curStack;
};
/**************************************************************************** 
* 根据当前的快照，以及全局的符号表和作用域，进入或退出作用域，以恢复当前情况的下的快照
****************************************************************************/
void enter_scope(snapshot *curSnapshot) {
    // TODO：进入内层作用域（对应push）
}
void exit_scope(snapshot *curSnapshot) {
    // TODO：退出内层作用域（对应pop）
}
void enter_innermost_scope(snapshot *curSnapshot) {
    // TODO：进入最内层作用域（用来初始化到全局的作用域）
}
```

### 总结

因为前一周准备电子的期末考试一直拖着没写，五一放假通宵写完了。这章其实不太难，理清每个指令的思路后写起来比较流畅，但是回过头看可读性实在是差。比较繁琐的是填上lab2的坑，填坑的方法写在上面了，希望后面的实验不要有更多的坑......
最后，我认为假设所有变量甚至域名都是全局是一件不合理的事情，因此我给出了实现局部作用域思路，代码也有很多重复的部分可以优化，因此后续还可以继续改改！






