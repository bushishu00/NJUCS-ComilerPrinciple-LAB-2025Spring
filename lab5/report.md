## Lab5 实验报告

### 学生信息

姓名：李子沐；学号：221180029；邮箱：221180029@smail.nju.edu.cn

### 实验环境和编译方法

目录结构为
├── Code
│   ├── 框架代码内容
│   ├── ...
├── README
├── Test
│   ├── 1.ir
│   ├── ...
├── Out
│   ├── 1.ir
│   ├── ...
├── parser
├── report.md

编译方法：进入Code/目录后make即可


若当前在Code/目录，可以通过运行下面的命令进行测试：
```shell
make
./parser ../Test/1.ir ../Out/1.ir
```

### 实现功能和细节

完成了框架代码中的所有TODO。框架代码只针对了全局做优化，因此应该没有完成对于基本块内的局部优化
局部优化的应当不是难事，但是要到ddl了所以摆了（
实现思路如下：
1. 设计数据结构多叉树Node，其标号op为union类，可以是任何运算符或某个变量；可以有多个孩子（双目运算符就俩，单目就一，三目就仨）
2. 公共子表达式消除：对于每个多叉树，若有两个节点的标号+孩子都一样，那么就是公共表达式；删除其中一个，并融合链接到两个节点的边
3. 死代码消除：没有父母的变量删除
4. 常量折叠：对于标号为变量，孩子为常数的，进行替换
5. 代数恒等式替换：对于某个子树，若同一深度的所有节点有一个公共的孩子，那么将这个孩子连接到上一级节点。
6. 重复2-5

其他的框架代码修改基本就是对着注释修改，没有啥创新的内容。
在Code/src/IR_optimize/constant_propagation.c的meetValue中，使用了查表（还有点意思）。主要是觉得反复的if判断有些麻烦，且容易漏情况。
```c
    CPValue U = get_UNDEF();
    CPValue N = get_NAC();
    CPValue C = v1.const_val == v2.const_val? v1: N;
    CPValue lut[3][3] = {{U, v1, N}, 
                         {v2, C, N}, 
                         {N,  N, N}};
    return lut[v1.kind][v2.kind];
```

### 总结

框架太牛了，过了一遍guidance以及框架代码本来没咋听优化但是也懂了。框架基本把答案喂到嘴里，理解了数据流分析之后非常简单。
编译原理的实验到此为止了，在此感谢助教，感谢谭老师！








